{-# Language DeriveDataTypeable #-}
{-# Language RecordWildCards #-}

module Main where

import Paths_hblend (version)
import Data.Version (showVersion)
import System.Console.CmdArgs.Implicit

import qualified Data.ByteString.Char8 as BC

import Control.Monad ((<=<))

import Data.Blend
  ( BBlend(..)
  , readBHeader, readBBlend
  , blendHeader, blendSdna
  , versionNumber
  , showSDNAAsHs, showSDNAAsSDNA
  , lookupStruct, showStruct
  , showStructAsHs, showStructAsHtml, showStructAsStruct, showStructParser
  , showBlockParser
  )

versionString :: String
versionString =
  "hblend " ++ showVersion version ++ " Copyright (c) 2009-2011 Vo Minh Thu."

main :: IO ()
main = (processCmd =<<) $ cmdArgs $
  modes
    [ dump, header, struct
    ]
  &= summary versionString
  &= program "hblend"

data DumpFormat = Code | Haskell | Html
  deriving (Data, Typeable)

data Cmd =
    Dump
    { dumpFormat :: DumpFormat
    , dumpFile :: FilePath
    }
  | Header
    { headerFiles :: [FilePath]
    }
  | Struct
    { structFile :: FilePath
    , structName :: String
    }
  deriving (Data, Typeable)

dump :: Cmd
dump = Dump
  { dumpFormat = Haskell
    &= typ "FORMAT"
    &= help "dump format"
    &= explicit
    &= name "f"
    &= name "format"
  , dumpFile = "" -- TODO mandatory
    &= typ "BLEND"
    &= help "blend filename"
    &= explicit
    &= name "b"
    &= name "blend-file"
  } &= help "Dump some information from a blend file."

header :: Cmd
header = Header
  { headerFiles = def
    &= typ "BLEND FILES"
    &= args
  } &= help "Dump the version header of blend files."

struct :: Cmd
struct = Struct
  { structName = def
    &= typ "STRING"
    &= help "structure name"
    &= explicit
    &= name "s"
    &= name "struct"
  , structFile = "" -- TODO mandatory
    &= typ "BLEND"
    &= help "blend filename"
    &= explicit
    &= name "b"
    &= name "blend-file"
  } &= help "Extract information for a specific structure from a blend file."

processCmd :: Cmd -> IO ()
processCmd Dump{..} = do
  blend <- readBBlend dumpFile
  case dumpFormat of
    Code -> dumpCode blend
    Haskell -> print blend
    Html -> dumpHtml blend

processCmd Header{..} = do
  mapM_ (print <=< readBHeader) headerFiles

processCmd Struct{..} = do
  blend <- readBBlend structFile
  case lookupStruct blend structName of
    Nothing -> putStrLn "No such structure."
    Just fs -> putStrLn $ showStruct fs
 
dumpCode :: BBlend -> IO ()
dumpCode blend = do
  let sdna = blendSdna blend
  putStrLn "{-# LANGUAGE OverloadedStrings #-}"
  putStrLn "-- automatically generated by hblend from a .blend file."
  putStrLn $ "module  Data.Blend.B" ++ BC.unpack (versionNumber $ blendHeader blend) ++ " where"
  putStrLn "import Data.Int"
  putStrLn "import Data.ByteString (ByteString)"
  putStrLn "import qualified Data.ByteString.Lazy as LB"
  putStrLn "import qualified Data.ByteString.Char8 as BC"
  putStrLn "import Data.Binary"
  putStrLn "import Data.Binary.Get (getByteString, getWord32le, runGet)"
  putStrLn "import Control.Monad (replicateM)"
  putStrLn "import Data.Blend hiding (Block)"
  mapM_ (putStrLn . showStructAsStruct) sdna
  putStrLn $ showSDNAAsSDNA sdna
  mapM_ (putStrLn . showStructAsHs) sdna
  mapM_ (putStrLn . showStructParser) sdna
  putStrLn $ showSDNAAsHs sdna
  putStrLn $ showBlockParser sdna

dumpHtml :: BBlend -> IO ()
dumpHtml blend = do
  let sdna = blendSdna blend
  putStrLn "<html><head><title>SDNA structures</title></head><body>\n"
  mapM_ putStrLn $ zipWith showStructAsHtml [(0::Integer)..] sdna
  putStrLn "</body></html>\n"
